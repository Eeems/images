#!/usr/bin/env bash

set -e
usage="$0 [OPTION]... IMAGESDIR [IMAGE] [TAG]
Build the Docker images under the IMAGESDIR directory. Optionally only build one image or tag
The build takes advantage of any reusable layer from previously built images.
Options:
    -h              Show this help message.
    -v              set -x"

helpflag=

error() {
    echo "Error: $1" >&2
    exit 1
}
status() {
    echo "=> $1" >&2
}
image-name() {
    echo "$1:${2:-latest}"
}
group(){
    echo "::group::$1"
}
endgroup(){
    echo "::endgroup::"
}


while getopts hv name; do
    case $name in
        h) helpflag=1 ;;
        v) set -x ;;
        *) error "Invalid option. Use the -h flag for more information." ;;
    esac
done

shift $((OPTIND - 1))

if [[ -n $helpflag ]]; then
    echo "$usage"
    exit
fi

if [[ $# -eq 0 ]]; then
    error "Missing IMAGESDIR arguments. Use the -h flag for more information."
fi

if [[ $# -gt 3 ]]; then
    error "Extraneous arguments. Use the -h flag for more information."
fi

imagesdir="$1"

# Enable BuildKit for better cache behavior
# See <https://docs.docker.com/engine/reference/builder/#buildkit>
export DOCKER_BUILDKIT=1

has-element() {
    local needle="$1"
    shift
    for element; do
        if [[ $needle == "$element" ]]; then
            return 0
        fi
    done
    return 1
}
push-mirror(){
    chronic docker tag "eeems/$1" "$2/$1"
    chronic docker image push "$2/$1"
}
build-tag(){
    local image="$1"
    local tag="$2"
    group "$image:$tag"
    if ! [ -d "$tag" ];then
        echo "Folder $image/$tag not found"
        endgroup
        return
    fi
    pushd $tag > /dev/null
    local target="$(image-name "$image" "$2")"
    status "Checking image '$target'"
    local hash=$(md5sum Dockerfile)
    local updates=0
    if ! docker pull "eeems/$target" &> /dev/null;then
        echo "  Image missing or could not be downloaded"
        updates=1
    elif [[ "$(docker run "eeems/$target" cat /hash 2> /dev/null)" != "$hash" ]];then
        echo "  Dockerfile changed"
        updates=1
    else
        local fromLine="$(head -n1 Dockerfile)"
        if [[ "ARG FROM" != "$fromLine" ]] && [[ "FROM" == "$(echo "$fromLine" | awk '{print $1}')" ]];then
          fromLine="$(echo "$fromLine" | awk '{print $2}')"
          if docker pull "${fromLine//$'\r'/}" | grep -q "Downloaded newer image";then
            echo "  New base image"
            updates=1
          fi
        fi
        if [ $updates -eq 0 ];then
            local output="$(docker run "eeems/$target" /usr/bin/checkupdates 2> /dev/null || true)"
            updates=$(echo "$output" | awk NF | wc -l)
            if [ $updates != 0 ];then
                echo "  $updates update(s) detected:"
                echo "$(echo -e "$output" | awk NF | sed 's/^/    /')"
            fi
        fi
    fi
    if [ $updates != 0 ];then
        status "Building image '$target'"
        echo "$hash" > .hash
        echo "COPY .hash /hash" > .tmp.dockerfile
        cat Dockerfile .tmp.dockerfile | docker image build \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            --build-arg FROM="$(image-name "$image" latest)" \
            --no-cache \
            --tag "eeems/$target" -f - .
        rm .hash
        rm .tmp.dockerfile
    fi
    chronic docker image push "eeems/$target"
    push-mirror "$target" "registry.eeems.codes"
    popd > /dev/null
    endgroup
}
build-image(){
    local start
    local image="$1"
    if ! [ -d "$image" ];then
        echo "Folder $image not found"
        return
    fi
    pushd "$image" > /dev/null
    if [[ $# -eq 1 ]];then
        local order=(latest)
        if [ -f .order ];then
            readarray -t order < .order
        fi
        for tag in "${order[@]}";do
            build-tag "$image" "$tag"
        done
        \ls | while read tag;do
            if [ -d "$tag" ] && ! has-element "$tag" "${order[@]}";then
                build-tag "$image" "$tag"
            fi
        done
    else
        build-tag "$image" "$2"
    fi
    popd > /dev/null
}

pushd "$imagesdir" > /dev/null
if [[ $# -eq 1 ]]; then
    \ls | while read image;do
        build-image "$image"
    done
elif [[ $# -eq 2 ]];then
    build-image "$2"
elif [[ $# -eq 3 ]];then
    build-image "$2" "$3"
else
    echo "Unknown number of arguments"
    echo "$usage"
fi
popd > /dev/null

status "Done"
